http://cache.baiducontent.com/c?m=9f65cb4a8c8507ed19fa950d100b92235c438014648c83493e8ed45f93130a1c187ba1a673731606d1c1793607f91857feb56b32610c7ffcda8bd65dddcad475729f27452f4fda0a05d368fe961a799671d601b4f358&p=c4759a46d6c502f60be2966f4a569f&newp=8b2a9701919757ff57ee9478475fcd231610db2151d4d2156b82c825d7331b001c3bbfb423271004d7cf796706af4a5bedf23372310923a3dda5c91d9fb4c57479cc606066&user=baidu&fm=sc&query=mysql+too+many+connections&qid=9a75f8900008a1f6&p1=4

查看数据库最大的连接数命令：
    show variables like 'max_connections';

show processlist;
    查看连接数，可以发现有很多连接处于sleep状态，这些其实是暂时没有用的，所以可以kill掉

set GLOBAL max_connections=1000;
    修改最大连接数，但是这不是一劳永逸的方法，应该要让它自动杀死那些sleep的进程。

show global variables like 'wait_timeout';
    这个数值指的是mysql在关闭一个非交互的连接之前要等待的秒数，默认是28800s

set global wait_timeout=300;
    修改这个数值，这里可以随意，最好控制在几分钟内

show global variables like 'interactive_timeout';
    修改这个数值，表示mysql在关闭一个连接之前要等待的秒数，至此可以让mysql自动关闭那些没用的连接，但要注意的是，正在使用的连接到了时间也会被关闭，因此这个时间值要合适
    set global interactive_timeout=300;

时间计算是无操作：
    sleep的时间，如果是query，机会在quertt time + sleep time(300s) 后被kill

问题：
    １．wait_timeout默认值为28800，大小需要根据项目来定。
    ２．wait_timeout过大有弊端，其体现就是MySQL里大量的SLEEP进程无法及时释放。
    ３．过小容易遇到MySQL server has gone away ，死锁等待等问题。
        https://www.cnblogs.com/fnlingnzb-learner/p/5984795.html

        有可能是因为某些原因导致超时，比如说程序中获取数据库连接时采用了Singleton的做法，虽然多次连接数据库，但其实使用的
        都是同一个连接，而且程序中某两次操作数据库的间隔时间超过了wait_timeout（SHOW STATUS能看到此设置），那么就可能出
        现问题。最简单的处理方式就是把wait_timeout改大，当然你也可以在程序里时不时顺手mysql_ping()一下，这样MySQL就知
        道它不是一个人在战斗。



