# Service

## 为什么引入Service

> 现在可以思考一个问题：为什么不直接通过pod来作为k8s的管理单位进行管理呢？

1. 当我们使用ReplicaSet或者ReplicationController做水平扩展scale的时候，Pod会在这个过程中被terminated，随着这个更替，Pod的ip等的也都在变幻。

2. 当我们使用Deployment的时候，我们去更新Docker Image Version，旧的Pods会被terminated，然后新的Pods创建，这个过程中，同样会发生Pod的ip改变等问题。从而难于对其进行访问。

## Service 是什么

Service定义了一个Pod的逻辑集合和访问这个集合的策略。集合是通过定义Service时提供的Label选择器完成的。

举个例子，我们假定有3个Pod的备份来完成一个图像处理的后端。这些后端备份逻辑上是相同的，前端不关心哪个后端在给它提供服务。虽然组成这个后端的实际Pod可能变化，前端客户端不会意识到这个变化，也不会跟踪后端。Service就是用来实现这种分离的抽象

## 定义一个Service


1.创建Services的方法：

1).kubectl expoese命令，会给我们的pod创建一个service，供外部访问

2).通过定义一个yml文件定义一个service类型的资源.

2).service主要有三种类型：一种叫clusterIP,一种叫nodePort,一种叫外部的LoadBalancer

	• ClusterIP: 仅仅使用一个集群内部的IP地址 - 这是默认值。选择这个值意味着你只想这个服务在集群内部才可以被访问到。

	•  NodePort: 在集群内部IP的基础上，在集群的每一个节点的端口上开放这个服务。你可以在任意<NodeIP>:NodePort地址上访问到这个服务。

LoadBalancer: 在使用一个集群内部IP地址和在NodePort上开放一个服务之外，向云提供商申请一个负载均衡器，会让流量转发到这个在每个节点上以<NodeIP>:NodePort的形式开放的服务上。

``` yaml
apiVersion: v1
kind: Service
metadata:
  labels:
    name: mysql
    role: service
  name: mysql-service
spec:
  ports:
    - port: 3306
      targetPort: 3306
      nodePort: 30964
  type: NodePort
  selector:
    mysql-service: "true"
```

上述内容定义了一个名为“mysql-service”的Servcie，它的服务端口为8080，拥有 “mysql-service=true”这个Label的所有Pod实例都属于它；当访问node上的30964端口时，其请求会转发到service对应的cluster IP的3306端口，并进一步转发到pod的3306端口

查看service更多信息

`kubectl get svc tomcat-service -o yaml`

## 发布服务 -Service类型

![service-type](./images/service-type.png)

Kubernetes的ServiceTypes能让你指定你想要哪一种服务。

- 默认的和基础的是ClusterIP，这会开放一个服务可以在`集群内部进行连接`。
- NodePort 和LoadBalancer是两种会`将服务开放给外部网络的类型`。

ServiceType字段的合法值是：

1. ClusterIP: 仅仅使用一个集群内部的IP地址 - 这是默认值。选择这个值意味着你只想这个服务在集群内部才可以被访问到。

2. NodePort: 在集群内部IP的基础上，在集群的每一个节点的端口上开放这个服务。你可以在任意 `<NodeIP>:NodePort`地址上访问到这个服务。

3. LoadBalancer: 在使用一个集群内部IP地址和在NodePort上开放一个服务之外，向云提供商申请一个负载均衡器，会让流量转发到这个在每个节点上以`<NodeIP>:NodePort`的形式开放的服务上。

## service负载分策略

RoundRobin：轮询模式，即轮询将请求转发到后端的各个pod上（默认模式）；

SessionAffinity：基于客户端IP地址进行会话保持的模式，第一次客户端访问后端某个pod，之后的请求都转发到这个pod上。
